#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Private function declaration ------------------------------------------- */
fsp_err_t icu_enable(void);
fsp_err_t icu_init(void);
void PWM_START(void);
void PWM_OPEN(void);
void Input_capture_Open(void);
void Input_capture_Enable(void);
static void gpt_deinit(timer_ctrl_t * p_ctrl);
void Blink_Leds();

/* Global variables ------------------------------------------------------ */
float pulse_time = 0.0f;	
#define RESET_VALUE     (0x00)
#define BUFF_SIZE       (30U)


uint64_t g_capture_count            = RESET_VALUE;
uint32_t g_capture_overflow         = RESET_VALUE;

volatile bool g_sw_press = false;
volatile bool b_start_measurement   = false;

#define USER_SW_IRQ_NUMBER        (0x03)   

/* ----------------------------------------------------------------------- */
uint64_t g_captured_time     = 0U;
uint32_t g_capture_overflows = 0U;
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	
	fsp_err_t err = FSP_SUCCESS;
	fsp_pack_version_t version   = {RESET_VALUE};
	char timer_buffer[BUFF_SIZE] = {RESET_VALUE};
	
	timer_info_t info = {.clock_frequency = RESET_VALUE, .count_direction = RESET_VALUE,
												 .period_counts =  RESET_VALUE};

	
	/* Version get API for FLEX pack information */
  R_FSP_VersionGet(&version);
												 	
	/* Initialize External IRQ driver*/
  err = icu_init();
  /* Enable External IRQ driver*/
  err = icu_enable();
											
	/* Testing PWM Functions*/										 
	PWM_OPEN();
	PWM_START();

	/* Input Capture Enabling*/
	Input_capture_Open();
	Input_capture_Enable();	

 while(true)
 {
        /* Check for the flag from ISR callback */
        if (b_start_measurement)
        {
            /* Reset the flag */
            b_start_measurement = false;
            /* Get the period count and clock frequency */
            err =  R_GPT_InfoGet(&g_timer_ctrl, &info);

            g_capture_count = (info.period_counts * g_capture_overflow) + g_capture_count;
            /* Calculate the pulse time */
            pulse_time =(float)(((float)g_capture_count)/((float)info.clock_frequency));
        }
  }
	
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

/* Blink LED for Error */
void Blink_Leds()
{
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_HIGH);
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
	
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_LOW);		
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);

}


/* User defined callback */
void input_capture_user_callback(timer_callback_args_t *p_args)
{
    /* Check for the event */
    switch(p_args->event)
    {
        case TIMER_EVENT_CAPTURE_A :
        {
            /* Capture the count in a variable */
            g_capture_count     = p_args->capture;
            /* Set start measurement */
            b_start_measurement = true;
            break;
        }
        case TIMER_EVENT_CYCLE_END:
        {
            /* An overflow occurred during capture. */
            g_capture_overflow++;
            break;
        }
        default:
        {
            break;
        }
    } 
		
}
/* De-initializes GPT module */
static void gpt_deinit(timer_ctrl_t * p_ctrl)
{
    fsp_err_t err = FSP_SUCCESS;
    /* De-initialize GPT instances */
    err = R_GPT_Close(p_ctrl);
    if (FSP_SUCCESS != err)
    {
        Blink_Leds();
    }
}

/* This functions initializes ICU module */
fsp_err_t icu_init(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Open ICU module */
    err = R_ICU_ExternalIrqOpen(&g_external_irq_ctrl, &g_external_irq_cfg);

    return err;
}

/* This function enables external interrupt for specified channel ------- */
fsp_err_t icu_enable(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Enable ICU module */
    err = R_ICU_ExternalIrqEnable(&g_external_irq_ctrl);

    return err;
}


/* This function closes opened ICU module before the project ends up in an Error Trap */
void icu_deinit(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Close ICU module */
    err = R_ICU_ExternalIrqClose(&g_external_irq_ctrl);
}

/* User defined external irq callback ------------------------------------- */
void irq_ep_callback(external_irq_callback_args_t *p_args)
{
    /* Make sure it's the right interrupt */
    if(USER_SW_IRQ_NUMBER == p_args->channel)
    {
        g_sw_press = true;
    }
}

/* This functions open the timer module ----------------------------------- */
void PWM_OPEN(void)
{
  fsp_err_t err = FSP_SUCCESS;

	/* Open GPT instance as a periodic timer */
  err = R_GPT_Open(&g_timer_ctrl, &g_timer_cfg);	

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This function start the timer module ---------------------------------- */
void PWM_START(void)
{
	fsp_err_t err = FSP_SUCCESS;
	/* Start GPT timer in periodic mode */
	err = R_GPT_Start(&g_timer_ctrl);	
		 
  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This functions open the timer iput capture module ------------------------ */
void Input_capture_Open(void)
{
  fsp_err_t err = FSP_SUCCESS;

	/* Open the module. */											 
	err = R_GPT_Open(&g_input_capture_ctrl, &g_input_capture_cfg);

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This function enable the timer input capture module -------------------- */
void Input_capture_Enable(void)
{
	fsp_err_t err = FSP_SUCCESS;

	/* enable low GPT timer in periodic mode */
	err = R_GPT_Enable(&g_input_capture_ctrl);

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}
