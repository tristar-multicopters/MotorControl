#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Public Functions ----------------------------------------------- */
void PWM_START(void);
void PWM_OPEN(void);
void Blink_Leds(void);
void Input_capture_Open(void);
void Input_capture_Enable(void);

/* Global defines -------------------------------------------------- */
#define RESET_VALUE     (0x00)
#define BUFF_SIZE       (30U)
/* Gloabal Variables ----------------------------------------------- */
uint64_t g_captured_time     = 0U;
uint32_t g_capture_overflows = 0U;

uint64_t g_capture_count     = RESET_VALUE;
uint32_t temp_g_capture_count     = RESET_VALUE;
uint32_t g_capture_overflow  = RESET_VALUE;
float pulse_time = 0.0f;

volatile bool g_sw_press = false;
volatile bool b_start_measurement   = false;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	/* Testing PWM Functions*/										 
	PWM_OPEN();
	PWM_START();
	
	/* Input Capture Enabling*/
	Input_capture_Open();
	Input_capture_Enable();									 
	
	while (1)
	{
				/* Check for the flag from ISR callback */
        if (b_start_measurement)
        {
            /* Reset the flag */
            b_start_measurement = false;
            g_capture_count = (g_capture_overflows) + g_capture_count;
        }     
	}											 										 
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
/* ------------------------------------ Code Start ------------------------------------ */
/* ------------------------------------------------------------------------------------ */

/* Blink LED for Error -------------------------------------------------------- */
void Blink_Leds(void)
{
	/* Turn Off LED */
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_HIGH);
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
	/* Turn ON LED */
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_LOW);		
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
}


/* This functions open the timer module ----------------------------------- */
void PWM_OPEN(void)
{
  fsp_err_t err = FSP_SUCCESS;

	/* Open GPT instance as a periodic timer */
  err = R_GPT_Open(&g_timer_ctrl, &g_timer_cfg);

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This function start the timer module ---------------------------------- */
void PWM_START(void)
{
	fsp_err_t err = FSP_SUCCESS;

	/* Start GPT timer in periodic mode */
	err = R_GPT_Start(&g_timer_ctrl);	 

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This functions open the timer iput capture module ------------------------ */
void Input_capture_Open(void)
{
  fsp_err_t err = FSP_SUCCESS;

	/* Open the module. */											 
	R_AGT_Open(&g_timer0_ctrl, &g_timer0_cfg);

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}

/* This function enable the timer input capture module -------------------- */
void Input_capture_Enable(void)
{
	fsp_err_t err = FSP_SUCCESS;

	/* enable low GPT timer in periodic mode */
	err = R_AGT_Enable(&g_timer0_ctrl);	 

  if (FSP_SUCCESS != err)
  {
		Blink_Leds();
  }
}


/* This function is the low timer capture callback ------------------------ */
void timer_capture_callback (timer_callback_args_t * p_args)
{
	    /* Check for the event */
    switch(p_args->event)
    {
        case TIMER_EVENT_CAPTURE_A :
        {
            /* Capture the count in a variable */
            g_capture_count     = p_args->capture;
            /* Set start measurement */
            b_start_measurement = true;
            break;
        }
        case TIMER_EVENT_CYCLE_END:
        {
            /* An overflow occurred during capture. */
            g_capture_overflow++;
            break;
        }
        default:
        {
            break;
        }
    }		
}
