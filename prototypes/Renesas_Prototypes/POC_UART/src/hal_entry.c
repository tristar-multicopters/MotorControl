#include "hal_data.h"
#include "Driver_USART.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


typedef struct
{
  int16_t q;
  int16_t d;
} qd_t;

typedef struct
{
  int16_t alpha;
  int16_t beta;
} alphabeta_t;


int16_t g_hELAngle;
qd_t g_volt_q_d;
uint16_t g_dac[2];
alphabeta_t g_volt_alpha_beta;
    char buffer[20];
    uint16_t toSend;

#define SCI_B_UART_BAUDRATE_19200             (19200)
#define SCI_B_UART_BAUDRATE_9600               (9600)
#define SCI_B_UART_BAUDRATE_31250             (31250)
#define SCI_B_UART_BAUDRATE_115200           (115200)
#define SCI_B_UART_BAUDRATE_ERROR_PERCENT_5    (5000)
#define TRANSFER_LENGTH 1

void example_callback (uart_callback_args_t * p_args);
static void PWMC_park_clarke(qd_t Vqd, int16_t Angle, alphabeta_t * p_handle);
void r_sci_b_uart_baud_example (void);

uint8_t  g_dest[TRANSFER_LENGTH] ;
uint8_t  g_src[TRANSFER_LENGTH] = {0x55};
uint8_t  g_out_of_band_received[TRANSFER_LENGTH];
uint32_t g_transfer_complete = 0;
uint32_t g_receive_complete  = 0;
uint32_t g_out_of_band_index = 0;
uint32_t Count = 0;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{

    g_volt_q_d.q = 1000;
	g_volt_q_d.d = 0;
    //r_sci_b_uart_baud_example(); 
    /* Open the transfer instance with initial configuration. */
    fsp_err_t err = R_SCI_B_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    r_sci_b_uart_baud_example(); 
    assert(FSP_SUCCESS == err);
    g_transfer_complete = 1;
    while(1)
    {
        if(g_transfer_complete && Count > 0)
        {    
            g_transfer_complete = 0;
            Count --;
             
            g_hELAngle += 100;
            PWMC_park_clarke(g_volt_q_d, g_hELAngle, &g_volt_alpha_beta);        
           // err = R_SCI_B_UART_Read(&g_uart0_ctrl, g_dest, TRANSFER_LENGTH);
           // assert(FSP_SUCCESS == err);
            //err = R_SCI_B_UART_Write(&g_uart0_ctrl, g_src, TRANSFER_LENGTH);
           // assert(FSP_SUCCESS == err);

            toSend =  (uint16_t) (g_volt_alpha_beta.alpha + 32768)/16;
    	    sprintf(buffer,"%d\r",toSend);
            
            err = R_SCI_B_UART_Write(&g_uart0_ctrl, buffer, 5);
            assert(FSP_SUCCESS == err);
            
            //R_DAC_Write(g_dac0.p_ctrl, (uint16_t) ((g_volt_alpha_beta.alpha + 32768)/16));			// Output at PA06
            //R_DAC_Write(g_dac1.p_ctrl, (uint16_t) ((g_volt_alpha_beta.beta + 32768)/16));				// Output at PA07
			
            R_BSP_SoftwareDelay (5,BSP_DELAY_UNITS_MILLISECONDS);
        }        
    }


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}


void r_sci_b_uart_baud_example (void)
{
    sci_b_baud_setting_t baud_setting;
    uint32_t             baud_rate                 = SCI_B_UART_BAUDRATE_115200;
    bool                 enable_bitrate_modulation = false;
    uint32_t             error_rate_x_1000         = SCI_B_UART_BAUDRATE_ERROR_PERCENT_5;
    
    fsp_err_t err = R_SCI_B_UART_BaudCalculate(baud_rate, enable_bitrate_modulation, error_rate_x_1000, &baud_setting);
    assert(FSP_SUCCESS == err);
    err = R_SCI_B_UART_BaudSet(&g_uart0_ctrl, (void *) &baud_setting);
    assert(FSP_SUCCESS == err);
}



static void PWMC_park_clarke(qd_t Vqd, int16_t Angle, alphabeta_t * p_handle)
{
		float fELAngle = 0;
		float sin,cos;
	
		fELAngle = (float) Angle/10430;
		sincosf(fELAngle, &sin, &cos);														// TMU is a part of BSP
		p_handle->alpha = (int16_t) (Vqd.d*sin + Vqd.q*cos);
		p_handle->beta = (int16_t) (Vqd.q*sin - Vqd.d*cos) ;

}

    
void uart_callback (uart_callback_args_t * p_args)
{
    /* Handle the UART event */
    switch (p_args->event)
    {
        /* Received a character */
        case UART_EVENT_RX_CHAR:
        {
            /* Only put the next character in the receive buffer if there is space for it */
            if (sizeof(g_out_of_band_received) > g_out_of_band_index)
            {
                /* Write either the next one or two bytes depending on the receive data size */
                if (UART_DATA_BITS_8 >= g_uart0_cfg.data_bits)
                {
                    g_out_of_band_received[g_out_of_band_index++] = (uint8_t) p_args->data;
                }
                else
                {
                    uint16_t * p_dest = (uint16_t *) &g_out_of_band_received[g_out_of_band_index];
                    *p_dest              = (uint16_t) p_args->data;
                    g_out_of_band_index += 2;
                }
               
            }
             Count = 200;
            break;
        }
        /* Receive complete */
        case UART_EVENT_RX_COMPLETE:
        {
            g_receive_complete = 1;
            break;
        }
        /* Transmit complete */
        case UART_EVENT_TX_COMPLETE:
        {
            g_transfer_complete = 1;
            break;
        }
        default:
        {
        }
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

