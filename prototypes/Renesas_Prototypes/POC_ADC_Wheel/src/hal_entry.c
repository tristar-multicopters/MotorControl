#include "hal_data.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* -- Externes ----------------------------------------------- */

extern const adc_b_scan_cfg_t g_adc_b0_scan_cfg;

/* -- Defines & Variables ------------------------------------ */

#define SECUNIT     1000000 // uS to Second conversion
#define MSECUNIT    1000    // uS to mSecond conversion
#define THRESHOLD   25000   // ADC threshold for Up front detect

#define POLENBR     4   // Number of motor Pole
#define TICK        50  // Timer Tick for 50us
#define HERZ        60  // RPM Hz factor

uint16_t ADC_Value = 0;
uint16_t Cycle = 0; 
uint16_t Count = 0;

uint32_t FreqmSec = 0;
uint32_t Freq = 0;
uint32_t RPM = 0;

/* -- Functions ---------------------------------------------- */

fsp_err_t ADC_Initialize ();
fsp_err_t ADC_Enable ();
fsp_err_t ADC_Calibrate ();
fsp_err_t ADC_Read (void);
fsp_err_t GPT_Timer_Start (timer_ctrl_t * const p_timer_ctl);
fsp_err_t GPT_Timer_Init(timer_ctrl_t * const p_timer_ctl, timer_cfg_t const * const p_timer_cfg);

/*******************************************************************************************************************//**
 * main() is generated by the RA Configurn editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	/* Timer init */
	GPT_Timer_Init(&g_timer_ctrl, &g_timer_cfg);
	/* Timer Start */
	GPT_Timer_Start (&g_timer_ctrl);  
    // Initialize ADC
    ADC_Initialize();
    // Enable ADC
    ADC_Enable();
    // Calibrate ADC
    ADC_Calibrate();

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
/*******************************************************************************************************************//**
 * Timer Funcitons
 **********************************************************************************************************************/

/* 
 *  Start GPT Timer 
 */
fsp_err_t GPT_Timer_Start (timer_ctrl_t * const p_timer_ctl)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Starts GPT timer */
    err = R_GPT_Start(p_timer_ctl);
    if (FSP_SUCCESS != err)
    {
			err = true;
    }
    return err;
}

/* 
 *  Initialize GPT Timer 
 */
fsp_err_t GPT_Timer_Init(timer_ctrl_t * const p_timer_ctl, timer_cfg_t const * const p_timer_cfg)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Initialize GPT Timer */
    err = R_GPT_Open(p_timer_ctl, p_timer_cfg);
    if (FSP_SUCCESS != err)
    {
        err = true;
    }
    return err;
}
/*******************************************************************************************************************//**
 * ADC Funcitons
 **********************************************************************************************************************/

/* 
 *  ADC Callback routine for Capture 
 */
void AC_ADC(adc_callback_args_t * p_args)
{
    // Read ADC input Value
    ADC_Read();
    // Detect Pulse count period
	if (ADC_Value > THRESHOLD)
    {
        Count++;
    }
    else
    {
        if (Count!=0)
        {
            Cycle = Count;
            FreqmSec = (TICK * Cycle) / MSECUNIT;
            Freq = SECUNIT / (TICK * Cycle);
            RPM = (Freq * HERZ ) / 4;
        }
        Count = 0;
    }
}

/* 
 *  ADC Initialize
 */
fsp_err_t ADC_Initialize ()
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_ADC_B_Open(&g_adc_ctrl, &g_adc_cfg);
    assert(FSP_SUCCESS == err);
    return err;
}

/* 
 *  ADC Enable
 */
fsp_err_t ADC_Enable ()
{
    fsp_err_t err = FSP_SUCCESS;
    /* Enable channels. */
    err = R_ADC_B_ScanCfg(&g_adc_ctrl, &g_adc_scan_cfg);
    assert(FSP_SUCCESS == err);
    return err;   
}

/* 
 *  ADC Calibrate
 */
fsp_err_t ADC_Calibrate ()
{
    fsp_err_t err = FSP_SUCCESS;
    err = R_ADC_B_Calibrate(&g_adc_ctrl, NULL);
    assert(FSP_SUCCESS == err);
    /* Wait for calibration to complete */
    adc_status_t status = {.state = ADC_STATE_SCAN_IN_PROGRESS};
    while ((ADC_STATE_SCAN_IN_PROGRESS == status.state) &&
           (FSP_SUCCESS == err))
    {
        R_BSP_SoftwareDelay(1, BSP_DELAY_UNITS_MILLISECONDS);
        err = R_ADC_B_StatusGet(&g_adc_ctrl, &status);
    }
    assert(FSP_SUCCESS == err);
    /* Start one or more scan groups by calling R_ADC_B_ScanGroupStart(). Alternatively, all scan groups may be started
     * by calling R_ADC_B_ScanCfg(). */
    (void) R_ADC_B_ScanGroupStart(&g_adc_ctrl, ADC_GROUP_MASK_0);
    /* Wait for conversion to complete. */
    status.state = ADC_STATE_SCAN_IN_PROGRESS;
    while (ADC_STATE_SCAN_IN_PROGRESS == status.state)
    {
        (void) R_ADC_B_StatusGet(&g_adc_ctrl, &status);
    }
    return err;
}

/* 
 *  ADC Read Value
 */
fsp_err_t ADC_Read (void)
{
  fsp_err_t err = FSP_SUCCESS;
  /* Read converted data. */
  err = R_ADC_B_Read(&g_adc_ctrl, ADC_CHANNEL_20, &ADC_Value);
  assert(FSP_SUCCESS == err);
  return err;
}
