#include "hal_data.h"
#include "r_iir_api.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
//#include "ADC_Func.h"
//#include "Timer_Func.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


typedef struct
{
  int16_t q;
  int16_t d;
} qd_t;

typedef struct
{
  int16_t alpha;
  int16_t beta;
} alphabeta_t;

fsp_err_t initIIRFilter(void);
void initDAC(void);
static void PWMC_park_clarke(qd_t Vqd, int16_t Angle, alphabeta_t * p_handle);
/* Boolean flag to determine one-shot mode timer is expired or not.*/
bool volatile g_one_shot_expired  = false;
/* Store Timer open state*/
uint8_t g_timer_open_state = RESET_VALUE;
bool b_ready_to_read = false;
bool b_NewAdcData = false;

float FilterOutput = 0; 
float FilterInput = 0;
uint32_t g_dac;
uint16_t g_dacOut;



int16_t g_hELAngle;
qd_t g_volt_q_d;
alphabeta_t g_volt_alpha_beta;

#define NUMSAMPLES 1

#define FILTER_STAGE_NUM    (2)
/* Biquad coefficients (4th order Butterworth 200Hz lowpass on 44.1KHz input) */
iir_filter_coeffs_t gp_iirfa0_filter_coeffs[FILTER_STAGE_NUM] =
{
    {
        .b0 = 1.000000000F,
        .b1 = 0, //2.000000000F,
        .b2 = 0, //1.000000000F,
        .a1 = 0, //-1.947914029F,
        .a2 = 0, //0.948705125F,
    },
    {
        .b0 = 1.000000000F,
        .b1 = 0, //2.000000000F,
        .b2 = 0, //1.000000000F,
        .a1 = 0, //-1.977625722F,
        .a2 = 0, //0.978428884F,
    },
};
/* Biquad state data (clear to start) */
iir_filter_state_t gp_iirfa0_filter_state[FILTER_STAGE_NUM] = {0};
/* Filter configuration */
iir_filter_cfg_t g_iirfa0_filter_cfg =
{
    .p_filter_coeffs = gp_iirfa0_filter_coeffs, // Pointer to filter coefficient array
    .p_filter_state  = gp_iirfa0_filter_state,  // Pointer to filter state data array
    .stage_base      = 0,                       // Which hardware biquad stage to start allocation from (0-31)
    .stage_num       = 2,                       // Number of stages to allocate
};


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    
       
	fsp_err_t err;
    
	initDAC();
    err = initIIRFilter();
    
    if(err != FSP_SUCCESS)
    {
       while(1);   
    }    
    
    /* Timer init */
	err = init_gpt_timer(&g_timer0_ctrl, &g_timer0_cfg);
	/* Timer Start */
	err = start_gpt_timer (&g_timer0_ctrl);   
	
    
    /* Start ADC port */
	read_process_start();
	
       
    while(1)
    {
       if(b_NewAdcData) // Wait for new ADC value
       {
          b_NewAdcData = false; 
          //Transform the ADC value into a float 
          //FilterInput = ((float) g_adc_b_data);
          memcpy(&FilterInput,&g_adc_b_data,4);
           
          //Send the value to the filter
          // Filter data 
          FilterOutput = R_IIRFA_SingleFilter(&g_iirfa0_ctrl, FilterInput);

          //g_dac = (uint16_t)(FilterOutput); 
          
          //memcpy(&g_dac,&FilterOutput,4);

           
          R_DAC_Write(g_dac0.p_ctrl, (uint16_t) g_dac);
           
           // R_IIRFA_Filter will return FSP_ERR_INVALID_RESULT when one or more calculations results in infinity. 
          if (FSP_ERR_INVALID_RESULT == err)
          {
              // Handle error 
              while(1);
          }
          else
          {
              assert(FSP_SUCCESS == err);
          }
       }
       
        //Generating sinus wave
       	g_hELAngle += 1;
		PWMC_park_clarke(g_volt_q_d, g_hELAngle, &g_volt_alpha_beta);
	
		R_DAC_Write(g_dac1.p_ctrl, (uint16_t) ((g_volt_alpha_beta.alpha + 32768)/16));						// Output at PA06
		
	    //R_BSP_SoftwareDelay (50,BSP_DELAY_UNITS_MICROSECONDS);
    
    }
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}


fsp_err_t initIIRFilter(void)
{
      fsp_err_t err;
    /* Initialize the IIRFA module */
    err = R_IIRFA_Open(&g_iirfa0_ctrl, &g_iirfa0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    assert(FSP_SUCCESS == err);
    /* Initialize filter coefficients and state variables */
    err = R_IIRFA_Configure(&g_iirfa0_ctrl, &g_iirfa0_filter_cfg);
    assert(FSP_SUCCESS == err);

    return err;

}


static void PWMC_park_clarke(qd_t Vqd, int16_t Angle, alphabeta_t * p_handle)
{
		float fELAngle = 0;
		float sin,cos;
	
		fELAngle = (float) Angle/10430;
		sincosf(fELAngle, &sin, &cos);														// TMU is a part of BSP
		p_handle->alpha = (int16_t) (Vqd.d*sin + Vqd.q*cos);
		p_handle->beta = (int16_t) (Vqd.q*sin - Vqd.d*cos) ;

}

void initDAC(void)
{
	// Initialize variables
	g_dac = 0;
	g_volt_q_d.q = 25000;
	g_volt_q_d.d = 0;
	g_hELAngle = 0;
	g_dacOut = 0;
	
	// DAC Setting
    R_DAC_Open(g_dac0.p_ctrl,g_dac0.p_cfg);
	R_DAC_Open(g_dac1.p_ctrl,g_dac1.p_cfg);
			
    R_DAC_Start(g_dac0.p_ctrl);
    R_DAC_Start(g_dac1.p_ctrl);
    
    R_DAC_Write(g_dac0.p_ctrl, (uint16_t) g_dac);
    R_DAC_Write(g_dac1.p_ctrl, (uint16_t) g_dacOut);			
	
}



/*****************************************************************************************************************
			ADC callback call after timer trigger
 ****************************************************************************************************************/
void AC_ADC(adc_callback_args_t * p_args)
{
	fsp_err_t err;
	if (true == b_ready_to_read)
	{
		/* Read ADC each timer trigger */
		err = adc_read_data();
	}
}


#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

/*****************************************************************************************************************
			Leds Blink for error behaviour
 ****************************************************************************************************************/
static void LEDs_Blink(void)
{
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_HIGH);
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
	
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_LOW);		
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
}
/*****************************************************************************************************************
			ADC Call start
 ****************************************************************************************************************/
fsp_err_t read_process_start(void)
{
	  fsp_err_t err = FSP_SUCCESS;     // Error status
    err = adc_scan_start();
    return err;
}	
/*****************************************************************************************************************
			ADC start scanning data
 ****************************************************************************************************************/
static fsp_err_t adc_scan_start(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status
    if (false == b_ready_to_read)
    {
        /* Open/Initialize ADC module */

        err = R_ADC_B_Open (&g_adc_b_ctrl, &g_adc_b_cfg);
        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }

        /* Configures the ADC scan parameters */
        err = R_ADC_B_ScanCfg (&g_adc_b_ctrl, &g_adc_b_scan_cfg);


        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        };
        /* Start the ADC scan*/
        err = R_ADC_B_ScanStart(&g_adc_b_ctrl);

        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }
        /* Indication to start reading the adc data */
        b_ready_to_read = true;
    }
    else
    {
        LEDs_Blink();
    }
    return err;
}
/*****************************************************************************************************************
			ADC stop scanning data
 ****************************************************************************************************************/
static fsp_err_t adc_scan_stop(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status

    /* Stop the scan if adc scan is started in continous scan mode else ignore */
    if((ADC_MODE_SINGLE_SCAN != g_adc_b_cfg_extend.adc_b_mode) && (true == b_ready_to_read ))

        {
					err = R_ADC_B_ScanStop (&g_adc_b_ctrl);

					/* handle error */
					if (FSP_SUCCESS != err)
					{
            /* ADC Failure message */
						LEDs_Blink();
            return err;
					}
        /* reset to indicate stop reading the adc data */
        b_ready_to_read = false;

        /* Close the ADC module*/
        err = R_ADC_B_Close (&g_adc_b_ctrl);

        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }

    }
    else
    {
        LEDs_Blink();
    }

    return err;
}

/*****************************************************************************************************************
			ADC read Data using Channel_0
 ****************************************************************************************************************/
fsp_err_t adc_read_data(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status

    /* Read the result */
    err = R_ADC_B_Read (&g_adc_b_ctrl, ADC_CHANNEL_0, &g_adc_b_data);
    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Failure message */
        LEDs_Blink();
        return err;
    }
    else
    {
        b_NewAdcData = true; 
      //  R_DAC_Write(g_dac0.p_ctrl, (uint16_t) g_adc_b_data);
    }    
    /* 1 Seconds Wait time between successive readings */
    //R_BSP_SoftwareDelay (ADC_READ_DELAY, BSP_DELAY_UNITS_SECONDS);
    return err;
}

static void deinit_adc_module(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Close ADC module */
    err = R_ADC_B_Close(&g_adc_b_ctrl);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Close failure message */
        LEDs_Blink();
    }
}

/*****************************************************************************************************************
			ADC Calibration
 ****************************************************************************************************************/
static fsp_err_t adc_start_calibration(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status
    adc_status_t adc_status;         // to get adc status

    /* Initiate ADC calibration */
    err = R_ADC_B_Calibrate (&g_adc_b_ctrl, NULL);

    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Failure message */
        LEDs_Blink();
        return err;
    }

    do
    {
        /* To get the adc status*/
        err = R_ADC_B_StatusGet (&g_adc_b_ctrl, &adc_status);
        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC status Failure message */
            LEDs_Blink();
            return err;
        }
    } while (ADC_STATE_IDLE != adc_status.state); //wait here till the calibration.It takes 24msec to 780msec based on clock

    LEDs_Blink();
    return err;
}

/*****************************************************************************************************************
			Initialize GPT timer.
 ****************************************************************************************************************/
fsp_err_t init_gpt_timer(timer_ctrl_t * const p_timer_ctl, timer_cfg_t const * const p_timer_cfg)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Initialize GPT Timer */
    err = R_GPT_Open(p_timer_ctl, p_timer_cfg);
    if (FSP_SUCCESS != err)
    {
        LEDs_Blink();
        return err;
    }
    return err;
}
/*****************************************************************************************************************
			Start GPT timers in periodic, one shot, PWM mode.
 ****************************************************************************************************************/
fsp_err_t start_gpt_timer (timer_ctrl_t * const p_timer_ctl)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Starts GPT timer */
    err = R_GPT_Start(p_timer_ctl);
    if (FSP_SUCCESS != err)
    {
			LEDs_Blink();
    }
    return err;
}
/*****************************************************************************************************************
			set  duty cycle of PWM timer.
 ****************************************************************************************************************/
fsp_err_t set_timer_duty_cycle(uint8_t duty_cycle_percent)
{
    fsp_err_t err                           = FSP_SUCCESS;
    uint32_t duty_cycle_counts              = RESET_VALUE;
    uint32_t current_period_counts          = RESET_VALUE;
    timer_info_t info                       = {(timer_direction_t)RESET_VALUE, RESET_VALUE, RESET_VALUE};

    /* Get the current period setting. */
    err = R_GPT_InfoGet(&g_timer0_ctrl, &info);
    if (FSP_SUCCESS != err)
    {
			LEDs_Blink();
    }
    else
    {
        /* update period counts locally. */
        current_period_counts = info.period_counts;
        //duty_cycle_counts =(uint32_t) ((uint64_t) (current_period_counts * duty_cycle_percent) / GPT_MAX_PERCENT);

        /* Duty Cycle Set API set the desired intensity on the on-board LED */
        //err = R_GPT_DutyCycleSet(&g_timer0_ctrl, duty_cycle_counts, TIMER_PIN);
        if(FSP_SUCCESS != err)
        {
					LEDs_Blink();
        }
    }
    return err;
}

/*****************************************************************************************************************
			Close the GPT HAL driver.
 ****************************************************************************************************************/
void deinit_gpt_timer(timer_ctrl_t * const p_timer_ctl)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Timer Close API call*/
    err = R_GPT_Close(p_timer_ctl);
    if (FSP_SUCCESS != err)
    {
        /* GPT Close failure message */
        LEDs_Blink();
    }

    /* Reset open state of timer*/
    g_timer_open_state = RESET_VALUE;
}