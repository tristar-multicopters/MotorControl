#include "hal_data.h"
#include "r_can.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/***********************************************************************************************************************
 * Macro definitions
 **********************************************************************************************************************/
#define WAIT_TIME                       (500U)             //wait time value
#define CAN_DESTINATION_MAILBOX_3       (3U)               //destination mail box number
#define CAN_MAILBOX_NUMBER_0            (0U)               //mail box number
#define CAN_FRAME_TRANSMIT_DATA_BYTES   (8U)               //data length
#define ZERO                            (0U)
#define NULL_CHAR                       ('\0')
#define RESET_VALUE                     (0x00)
/***********************************************************************************************************************
 * Private global variables
 **********************************************************************************************************************/
/* Flags, set from Callback function */
static volatile bool b_can_tx  = false;     //CAN transmission status
static volatile bool b_can_rx  = false;    //CAN receive status
static volatile bool b_can_err = false;    //CAN error status
/* CAN frames for tx and rx */
static can_frame_t g_can_tx_frame;         //CAN transmit frame
static can_frame_t g_can_rx_frame;         //CAN receive frame

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
	
	  fsp_err_t err = FSP_SUCCESS;
    uint32_t time_out = WAIT_TIME;                                   //time out
    fsp_pack_version_t version = {RESET_VALUE};
    uint8_t can_tx_msg[CAN_FRAME_TRANSMIT_DATA_BYTES] = "TX__MESG";  //data to be load in tx_frame while transmitting
    uint8_t can_rx_msg[CAN_FRAME_TRANSMIT_DATA_BYTES] = "RX__MESG";  //data to be load in rx_frame while acknowledging
   // char rtt_input_buf[BUFFER_SIZE_DOWN] = {NULL_CHAR,};

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Initialize CAN module */
    err = R_CAN_Open(&g_can0_ctrl, &g_can0_cfg);
    /* Error trap */
    if(FSP_SUCCESS != err)
    {
    }

    g_can_tx_frame.id = CAN_DESTINATION_MAILBOX_3;
    g_can_tx_frame.type = CAN_FRAME_TYPE_DATA;
    g_can_tx_frame.data_length_code = CAN_FRAME_TRANSMIT_DATA_BYTES;

    /* copy the tx data frame with TX_MSG */
    memcpy((uint8_t*)&g_can_tx_frame.data[ZERO], (uint8_t*)&can_tx_msg[ZERO], CAN_FRAME_TRANSMIT_DATA_BYTES);

    while (true)
    {
      
        /* transmit the data from mail box #0 with tx_frame */
        err = R_CAN_Write(&g_can0_ctrl, CAN_MAILBOX_NUMBER_0, &g_can_tx_frame);
        /* Error trap */
        if (FSP_SUCCESS != err)
        {
					while(1);
        }

        /* wait for transmit flag bit to set */
        while ((true != b_can_tx) && (--time_out));
        if (RESET_VALUE == time_out)
        {
					while(1);
        }
        /* Reset flag bit */
        b_can_tx = false;
				
        //memset(rtt_input_buf,NULL_CHAR,BUFFER_SIZE_DOWN);
        
        /* check if receive flag is set */
        if (true == b_can_rx)
        {
            /* Reset flag bit */
            b_can_rx = false;

            /* if received data is same as transmitted data then acknowledge with RX_MSG as received successful*/
            if (RESET_VALUE == strncmp((char*)&g_can_rx_frame.data[ZERO], (char*)&can_tx_msg[ZERO], CAN_FRAME_TRANSMIT_DATA_BYTES))
            {
             
                g_can_rx_frame.id = CAN_DESTINATION_MAILBOX_3;
                g_can_rx_frame.type = CAN_FRAME_TYPE_DATA;
                g_can_rx_frame.data_length_code = CAN_FRAME_TRANSMIT_DATA_BYTES;

                /* copy the rx_data frame as RX_MSG */
                memcpy((uint8_t*)&g_can_rx_frame.data[ZERO], (uint8_t*)&can_rx_msg[ZERO], CAN_FRAME_TRANSMIT_DATA_BYTES);

                /* Transmit the rx data frame as acknowledging the data transfer is successful */
                err = R_CAN_Write (&g_can0_ctrl, CAN_MAILBOX_NUMBER_0, &g_can_rx_frame);
                /* Error trap */
                if (FSP_SUCCESS != err)
                {
                }
                /* wait for transmit flag bit to set */
                while ((true != b_can_tx) && (--time_out));
                if (RESET_VALUE == time_out)
                {
                }
                /* Reset flag bit */
                b_can_tx = false;

            }
            /* check if received data is same as rx_msg then received an acknowledge for the transfer of data successful */
            else if (RESET_VALUE == strncmp((char*)&g_can_rx_frame.data[ZERO],(char*)&can_rx_msg[ZERO], CAN_FRAME_TRANSMIT_DATA_BYTES))
            {
            }
            /* if no data match then data transfer failed */
            else
            {
							while(1);
            }
            /* Reset the rx frame data */
            memset((uint8_t*)&g_can_rx_frame.data[ZERO],RESET_VALUE,CAN_FRAME_TRANSMIT_DATA_BYTES);
        }
        /* re initializing time out value */
        time_out = WAIT_TIME;
    }
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called when an CAN event is occurred and SET the respective flags.
 **********************************************************************************************************************/
void can_callback(can_callback_args_t *p_args)
{
    switch (p_args->event)
    {
        case CAN_EVENT_TX_COMPLETE:
        {
            b_can_tx = true;        //set flag bit
            break;
        }

        case CAN_EVENT_RX_COMPLETE:
        {
            b_can_rx = true;
            memcpy(&g_can_rx_frame, p_args->p_frame, sizeof(can_frame_t));  //copy the received data to rx_frame
            break;
        }

        case CAN_EVENT_MAILBOX_MESSAGE_LOST:    //overwrite/overrun error event
        case CAN_EVENT_BUS_RECOVERY:            //Bus recovery error event
        case CAN_EVENT_ERR_BUS_OFF:             //error Bus Off event
        case CAN_EVENT_ERR_PASSIVE:             //error passive event
        case CAN_EVENT_ERR_WARNING:             //error warning event
        case CAN_EVENT_ERR_BUS_LOCK:            //error bus lock
        case CAN_EVENT_ERR_CHANNEL:             //error channel
        case CAN_EVENT_ERR_GLOBAL:              //error global
        case CAN_EVENT_TX_ABORTED:              //error transmit abort
        case CAN_EVENT_TX_FIFO_EMPTY:           //error transmit FIFO is empty
        {
            b_can_err = true;                   //set flag bit
            break;
        }

    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
