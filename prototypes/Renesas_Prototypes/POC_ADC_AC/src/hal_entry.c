#include "hal_data.h"
//#include "ADC_Func.h"
//#include "Timer_Func.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Boolean flag to determine one-shot mode timer is expired or not.*/
bool volatile g_one_shot_expired  = false;
/* Store Timer open state*/
uint8_t g_timer_open_state = RESET_VALUE;
bool b_ready_to_read = false;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{

	fsp_err_t err;
	/* Timer init */
	err = init_gpt_timer(&g_timer0_ctrl, &g_timer0_cfg);
	/* Timer Start */
	err = start_gpt_timer (&g_timer0_ctrl);   
	/* Start ADC port */
	read_process_start();
	
	
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

/*****************************************************************************************************************
			ADC callback call after timer trigger
 ****************************************************************************************************************/
void AC_ADC(adc_callback_args_t * p_args)
{
	fsp_err_t err;
	if (true == b_ready_to_read)
	{
		/* Read ADC each timer trigger */
		err = adc_read_data();
	}
}


#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

/*****************************************************************************************************************
			Leds Blink for error behaviour
 ****************************************************************************************************************/
static void LEDs_Blink(void)
{
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_HIGH);
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
	
	R_IOPORT_PinWrite(&g_ioport_ctrl,BSP_IO_PORT_13_PIN_01,BSP_IO_LEVEL_LOW);		
	R_BSP_SoftwareDelay(100,BSP_DELAY_UNITS_MILLISECONDS);
}
/*****************************************************************************************************************
			ADC Call start
 ****************************************************************************************************************/
fsp_err_t read_process_start(void)
{
	  fsp_err_t err = FSP_SUCCESS;     // Error status
    err = adc_scan_start();
    return err;
}	
/*****************************************************************************************************************
			ADC start scanning data
 ****************************************************************************************************************/
static fsp_err_t adc_scan_start(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status
    if (false == b_ready_to_read)
    {
        /* Open/Initialize ADC module */

        err = R_ADC_B_Open (&g_adc_b_ctrl, &g_adc_b_cfg);
        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }

        /* Configures the ADC scan parameters */
        err = R_ADC_B_ScanCfg (&g_adc_b_ctrl, &g_adc_b_scan_cfg);


        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        };
        /* Start the ADC scan*/
        err = R_ADC_B_ScanStart(&g_adc_b_ctrl);

        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }
        /* Indication to start reading the adc data */
        b_ready_to_read = true;
    }
    else
    {
        LEDs_Blink();
    }
    return err;
}
/*****************************************************************************************************************
			ADC stop scanning data
 ****************************************************************************************************************/
static fsp_err_t adc_scan_stop(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status

    /* Stop the scan if adc scan is started in continous scan mode else ignore */
    if((ADC_MODE_SINGLE_SCAN != g_adc_b_cfg_extend.adc_b_mode) && (true == b_ready_to_read ))

        {
					err = R_ADC_B_ScanStop (&g_adc_b_ctrl);

					/* handle error */
					if (FSP_SUCCESS != err)
					{
            /* ADC Failure message */
						LEDs_Blink();
            return err;
					}
        /* reset to indicate stop reading the adc data */
        b_ready_to_read = false;

        /* Close the ADC module*/
        err = R_ADC_B_Close (&g_adc_b_ctrl);

        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            LEDs_Blink();
            return err;
        }

    }
    else
    {
        LEDs_Blink();
    }

    return err;
}

/*****************************************************************************************************************
			ADC read Data using Channel_0
 ****************************************************************************************************************/
fsp_err_t adc_read_data(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status

    /* Read the result */
    err = R_ADC_B_Read (&g_adc_b_ctrl, ADC_CHANNEL_0, &g_adc_b_data);
    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Failure message */
        LEDs_Blink();
        return err;
    }
    /* 1 Seconds Wait time between successive readings */
    R_BSP_SoftwareDelay (ADC_READ_DELAY, BSP_DELAY_UNITS_SECONDS);
    return err;
}

static void deinit_adc_module(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Close ADC module */
    err = R_ADC_B_Close(&g_adc_b_ctrl);
    /* Handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Close failure message */
        LEDs_Blink();
    }
}

/*****************************************************************************************************************
			ADC Calibration
 ****************************************************************************************************************/
static fsp_err_t adc_start_calibration(void)
{
    fsp_err_t err = FSP_SUCCESS;     // Error status
    adc_status_t adc_status;         // to get adc status

    /* Initiate ADC calibration */
    err = R_ADC_B_Calibrate (&g_adc_b_ctrl, NULL);

    /* handle error */
    if (FSP_SUCCESS != err)
    {
        /* ADC Failure message */
        LEDs_Blink();
        return err;
    }

    do
    {
        /* To get the adc status*/
        err = R_ADC_B_StatusGet (&g_adc_b_ctrl, &adc_status);
        /* handle error */
        if (FSP_SUCCESS != err)
        {
            /* ADC status Failure message */
            LEDs_Blink();
            return err;
        }
    } while (ADC_STATE_IDLE != adc_status.state); //wait here till the calibration.It takes 24msec to 780msec based on clock

    LEDs_Blink();
    return err;
}

/*****************************************************************************************************************
			Initialize GPT timer.
 ****************************************************************************************************************/
fsp_err_t init_gpt_timer(timer_ctrl_t * const p_timer_ctl, timer_cfg_t const * const p_timer_cfg)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Initialize GPT Timer */
    err = R_GPT_Open(p_timer_ctl, p_timer_cfg);
    if (FSP_SUCCESS != err)
    {
        LEDs_Blink();
        return err;
    }
    return err;
}
/*****************************************************************************************************************
			Start GPT timers in periodic, one shot, PWM mode.
 ****************************************************************************************************************/
fsp_err_t start_gpt_timer (timer_ctrl_t * const p_timer_ctl)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Starts GPT timer */
    err = R_GPT_Start(p_timer_ctl);
    if (FSP_SUCCESS != err)
    {
			LEDs_Blink();
    }
    return err;
}
/*****************************************************************************************************************
			set  duty cycle of PWM timer.
 ****************************************************************************************************************/
fsp_err_t set_timer_duty_cycle(uint8_t duty_cycle_percent)
{
    fsp_err_t err                           = FSP_SUCCESS;
    uint32_t duty_cycle_counts              = RESET_VALUE;
    uint32_t current_period_counts          = RESET_VALUE;
    timer_info_t info                       = {(timer_direction_t)RESET_VALUE, RESET_VALUE, RESET_VALUE};

    /* Get the current period setting. */
    err = R_GPT_InfoGet(&g_timer0_ctrl, &info);
    if (FSP_SUCCESS != err)
    {
			LEDs_Blink();
    }
    else
    {
        /* update period counts locally. */
        current_period_counts = info.period_counts;
        //duty_cycle_counts =(uint32_t) ((uint64_t) (current_period_counts * duty_cycle_percent) / GPT_MAX_PERCENT);

        /* Duty Cycle Set API set the desired intensity on the on-board LED */
        //err = R_GPT_DutyCycleSet(&g_timer0_ctrl, duty_cycle_counts, TIMER_PIN);
        if(FSP_SUCCESS != err)
        {
					LEDs_Blink();
        }
    }
    return err;
}

/*****************************************************************************************************************
			Close the GPT HAL driver.
 ****************************************************************************************************************/
void deinit_gpt_timer(timer_ctrl_t * const p_timer_ctl)
{
    fsp_err_t err = FSP_SUCCESS;

    /* Timer Close API call*/
    err = R_GPT_Close(p_timer_ctl);
    if (FSP_SUCCESS != err)
    {
        /* GPT Close failure message */
        LEDs_Blink();
    }

    /* Reset open state of timer*/
    g_timer_open_state = RESET_VALUE;
}